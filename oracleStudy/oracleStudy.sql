desc emp;  
 -- emp 테이블 구조보기
select * from emp; 
-- emp 테이블 내용보기

desc dept; 
-- dept 테이블 구조보기
select * from dept;
-- dept 테이블 내용보기

desc bonus; 
-- bonus 테이블 구조보기
select * from bonus; 
--bonus 테이블 내용보기

desc salgrade;  
-- salgrade 테이블 구조보기
select * from salgrade; 
-- salgrade 테이블 내용보기

select empno, ename, deptno from emp;
-- 테이블 부분 열 출력하기

select distinct deptno from emp; 
-- distinct 로 열 중복 제거하기

select distinct job, deptno from emp; 
-- distinct 로 열 여러개 중복 제거하기

select all job, deptno from emp; 
-- all로 중복되는 열 제거없이 그대로 출력하기

select ename, sal, sal*12+comm, comm from emp; 
-- 열에 연산식을 사용하여 출력하기

select ename, sal, sal+sal+sal+sal+sal+sal+sal+sal+sal+sal+sal+sal+comm, comm from emp;
-- 곱하기를 사용하지 않고 사원의 연간 총 수입 출력하기

select ename, sal, sal*12+comm as annsal, comm from emp;
-- 별칭을 사용하여 사원의 연간 총 수입 출력하기

select*from emp order by sal;
-- emp 테이블의 모든 열을 급여 기준으로 오름차순 정렬하기

select*from emp order by sal desc;
-- emp 테이블의 모든 열을 급여 기준으로 내림차순 정렬하기

select * from emp order by deptno asc, sal desc;
-- emp 테이블의 전체 열을 부서 번호 (오름차순) 와 급여(내림차순)로 정렬하기

select * from emp;
-- emp 테이블의 모든 열 출력하기

select * from emp where deptno = 30;
-- 부서 번호가 30인 데이터만 출력하기

select * from emp where mgr = 7698;
-- 사원 번호가 7698인 사원 정보만 나오도록 코드 만들기

select * from emp where deptno = 30 and job = 'SALESMAN';
-- and 연산자로 여러 개의 조건식 사용하기

select * from emp where deptno = 30 or job = 'CLERK';
-- or 연산자로 여러 개의 조건식 사용하기

select * from emp where sal * 12 = 36000;
-- 곱셈 산술 연산자를 사용한 예

select * from emp where sal >= 3000;
-- 대소 비교 연산자를 사용하여 출력하기

select * from emp where ename >= 'F';
-- 문자를 대소 비교 연산자로 비교하기(비교 문자열이 하나 일 때)

select * from emp where ename <= 'FORZ' ;
-- 문자열을 대소 비교 연산자로 비교하기(비교 문자열이 여러개 일때)

SELECT * FROM EMP WHERE SAL != 3000;
-- 등가 비교 연산자(!=)를 사용하여 출력하기

SELECT * FROM EMP WHERE SAL <> 3000;
-- 등가 비교 연산자(<>)를 사용하여 출력하기

SELECT * FROM EMP WHERE SAL ^= 3000;
-- 등가 비교 연산자(^=)를 사용하여 출력하기

SELECT * FROM EMP WHERE NOT SAL = 3000;
-- NOT 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN' OR JOB = 'CLERK';
-- OR 연산자를 사용하여 여러 개 조건을 만족하는 데이터 출력하기

SELECT * FROM EMP WHERE JOB IN ('MANAGER', 'SALESMAN', 'CLERK');
-- IN 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE JOB != 'MANAGER' AND JOB <> 'SALESMAN' AND JOB ^= 'CLERK' ;
-- 등가 비교 연산자와 AND 연산자를 사용해서 출력하기

SELECT * FROM EMP WHERE JOB NOT IN ('MANAGER', 'SALESMAN', 'CLERK');
-- IN 연산자와 논리 부정 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE SAL >= 2000 AND SAL <= 3000;
-- 대소 비교 연산자와 AND 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE SAL BETWEEN 2000 AND 3000;
-- BETWEEN A AND B 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE ENAME LIKE 'S%';
-- LIKE 연산자 사용하여 출력하기

SELECT * FROM EMP WHERE ENAME LIKE '_L%';
-- 사원 이름의 두 번째 글자가 L 인 사원만 출력하기

SELECT * FROM EMP WHERE ENAME LIKE '%AM%';
-- 사원 이름에 AM이 포함되어있는 사원 데이터만 출력하기

SELECT * FROM EMP WHERE ENAME NOT LIKE '%AM%';
-- 사원 이름에 AM이 포함되어 있지 않은 사원 데이터 출력하기

SELECT * FROM SOME_TABLE WHERE SOME_COLUMN LIKE'A\_A%' ESCAPE '\';
-- 와일드 카드 문자가 데이터 일부일 경우

SELECT ENAME, SAL, SAL*12+COMM AS ANNSAL, COMM FROM EMP;
-- 별칭을 사용하여 열 이름 출력하기

SELECT * FROM EMP WHERE COMM = NULL;
-- 등가 비교 연산자로 NULL 비교하기

SELECT * FROM EMP WHERE COMM IS NULL;
-- IS NULL 연산자를 사용하여 출력하기

SELECT * FROM EMP WHERE MGR IS NOT NULL ;
-- 직속 상관이 있는 사원 데이터만 출력하기

SELECT * FROM EMP WHERE SAL > NULL AND COMM IS NULL;
-- AND 연산자와 IS NULL 연산자 사용하기

SELECT * FROM EMP WHERE SAL > NULL OR COMM IS NULL;
-- OR 연산자와 IS NULL 연산자 사용하기

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION 
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO =20;
-- 집한 연산자 UNION을 를 사용하여 출력하기

-- SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
-- UNION SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO = 20;
-- 부정확한 수의 결과 열을 가지고 있기 때문에 오류

-- SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10 ;
-- UNION SELECT ENAME, EMPNO, DEPTNO, SAL FROM EMP WHERE DEPTNO = 20;
-- 대응하는 식과 같은 데이터 유형이여아 한다.

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10 
UNION 
SELECT SAL,JOB,DEPTNO,SAL FROM EMP WHERE DEPTNO = 20;
-- 집합 연산자(UNION)를 사용하여 출력하기 (출력 열 개수와 자료형이 같을 때)

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10 
UNION 
SELECT EMPNO,ENAME,SAL,DEPTNO FROM EMP WHERE DEPTNO = 10;
-- 집합 연산자(UNION)를 사용하여 출력하기 (출력 결과 데이터가 같을 때)

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL 
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;
-- 집합 연산자(UNION ALL)를 사용하여 출력하기 (출력 결과 데이터가 같을 때)

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP
MINUS
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;
-- 집합 연산자 (MINUS)를 사용하여 출력하기

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP
INTERSECT
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;
-- 집합 연산자(INTERSECT)를 사용하여 출력하기 

SELECT ENAME, UPPER(ENAME),LOWER(ENAME),INITCAP(ENAME) FROM EMP;
-- UPPER,LOWER,INITCAP 함수 사용하기

-- SELECT * FROM 게시판테이블 WHERE 게시판 제목 열 LIKE '%Oracle%' OR 게시판 본문 열 LIKE '%Oracle%'

SELECT * FROM EMP WHERE UPPER(ENAME)=UPPER('scott');
-- UPEER 함수로 문자열 비교하기 (사원 이름이 SCOTT 인 데이터 찾기)

SELECT * FROM EMP WHERE UPPER(ENAME) LIKE UPPER('%scott%');
-- UPEER 함수로 문자열 비교하기 (사원 이름에 SCOTT 단어를 포함한 데이터 찾기)

SELECT ENAME, LENGTH(ENAME) FROM EMP;
-- 선택한 열의 문자열 길이 구하기

SELECT ENAME, LENGTH(ENAME) FROM EMP WHERE LENGTH(ENAME) >= 5;
-- 사원 이름의 길이가 5 이상인 행 출력하기

SELECT LENGTH('한글'),LENGTHB('한글') FROM DUAL;
-- LENGTH 함수와 LENGTHB 함수 비교하기

SELECT JOB, SUBSTR(JOB, 1, 2), SUBSTR(JOB, 3, 2),SUBSTR(JOB, 5) FROM EMP;
-- SUBSTR 함수를 사용하는 예 SELECT JOB,SUBSTR(JOB, -LENGTH(JOB)),SUBSTR(JOB, -LENGTH(JOB),2),SUBSTR(JOB,-3) FROM EMP;
-- SUBSTR 함수 안에 다른 함수(LENGTH) 함께 사용하기

SELECT INSTR ('HELLO,ORACLE!','L') AS INSTR_1, INSTR('HELLO,ORACLE!','L',5) AS INSTR_2, INSTR('HELLO,ORACLE!','L',2,2) AS INSTR_3 FROM DUAL;
-- INSTR 함수로 문자열 데이터에서 특정 문자열 찾기

SELECT * FROM EMP WHERE INSTR(ENAME,'S') > 0;
-- INSTR 함수로 사원 이름에 문자 S가 있는 행 구하기

SELECT * FROM EMP WHERE ENAME LIKE '%S%';
-- LIKE 연산자로 사원 이름에 문자 S가 있는 행 구하기

SELECT '010-1234-5678' AS REPLACE_BEFORE, REPLACE('010-1234-5678','-',' ')AS REPLACE_1,REPLACE('010-1234-5678','-')AS REPLACE_2 FROM DUAL;
-- REPLACE 함수로 문자열 안에 있는 특정 문자 바꾸기

SELECT 'Oracle',LPAD('Oracle',10,'#') AS LPAD_1,RPAD('Oracle',10,'*')AS RPAD_1,LPAD('Oracle',10) AS LPAD_2, RPAD('Oracle',10) AS RPAD_2 FROM DUAL;
-- LAPE,RPAD 함수 사용하여 출력하기

SELECT CONCAT(EMPNO,ENAME), CONCAT (EMPNO, CONCAT(' : ' , ENAME)) FROM EMP WHERE ENAME = 'SCOTT' ;
-- 두 열 사이에 콜론(:) 넣고 연결하기

SELECT '[' || TRIM(' _ _Oracle_ _')||']' AS TRIM, 
'[' || TRIM(LEADING FROM' _ _Oracle_ _')||']' AS TRIM_LEADING,
'[' || TRIM(TRAILING FROM '_ _Oracle_ _')||']' AS TRIM_TRAILING,
'[' || TRIM(BOTH FROM'_ _Oracle_ _')||']' AS TRIM_BOTH 
FROM DUAL;
-- TRIM함수로 공백 제거하여 출력하기

SELECT '[' || TRIM('_' FROM '_ _Oracle_ _')||']' AS TRIM, 
'[' || TRIM(LEADING '_' FROM' _ _Oracle_ _')||']' AS TRIM_LEADING,
'[' || TRIM(TRAILING '_' FROM '_ _Oracle_ _')||']' AS TRIM_TRAILING,
'[' || TRIM(BOTH '_' FROM '_ _Oracle_ _')||']' AS TRIM_BOTH 
FROM DUAL;
--TRIM 함수로 삭제할 문자 _ 삭제 후 출력하기

-- 143 페이지 까지 함

-- 311 페이지 부터 시작
CREATE TABLE EMP_DDL(
EMPNO   NUMBER(4),
ENAME   VARCHAR2(10),
JOB     VARCHAR2(9),
MGR     NUMBER(4),
HIREDATE DATE,
SAL     NUMBER(7,2),
COMM    NUMBER(7,2),
DEPTNO  NUMBER(2)
);

DESC EMP_DDL;
-- 모든 열의 각 자료형을 정의해서 테이블 생성하기

CREATE TABLE DEPT_DDL AS SELECT * FROM DEPT;
DESC DEPT_DDL;
-- 다른 테이블을 복사하여 테이블 생성하기

SELECT * FROM DEPT_DDL;
-- DEPT_DDL 테이블 전체 조회하기

CREATE TABLE EMP_DDL_30 AS SELECT * FROM EMP WHERE DEPTNO = 30; 

SELECT * FROM EMP_DDL_30;
-- 다른 테이블의 일부를 복사하여 테이블 생성하기

CREATE TABLE EMPDEPT_DDL AS SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, D.DEPTNO, D.DNAME, D.LOC FROM EMP E, DEPT D WHERE 1<> 1;

SELECT * FROM EMPDEPT_DDL;
-- 다른 테이블을 복사하여 테이블 생성하기

CREATE TABLE EMP_ALTER AS SELECT * FROM EMP;

SELECT * FROM EMP_ALTER;
-- EMP 테이블을 복사하여 EMP_ALTER 테이블 생성하기

ALTER TABLE EMP_ALTER ADD HP VARCHAR2(20);

SELECT * FROM EMP_ALTER;
-- ALTER 명령어로 HP 열 추가하기

ALTER TABLE EMP_ALTER RENAME COLUMN HP TO TEL;

SELECT * FROM EMP_ALTER;
-- ALTER 명령어로 HP열 이름을 TEL 로 변경하기

ALTER TABLE EMP_ALTER MODIFY EMPNO NUMBER(5);DESC EMP_ALTER;
-- ALTER 명령어로 EMPNO열 길이 변경하기

ALTER TABLE EMP_ALTER DROP COLUMN TEL;

SELECT * FROM EMP_ALTER;
-- ALTER 명령어로 TEL열 삭제하기

RENAME EMP_ALTER TO EMP_RENAME;
-- 테이블 이름 변경하기

DESC EMP_ALTER;
-- 바꾸기 전 이름으로 테이블 구성 살펴보기 (바꿧으니 조회X)

SELECT * FROM EMP_RENAME;
-- 변경된 테이블 이름 (EMP_RENAME)으로 조회하기

TRUNCATE TABLE EMP_RENAME;

SELECT * FROM EMP_RENAME;
-- EMP_RENAME 테이블의 전체 데이터 삭제하기

DROP TABLE EMP_RENAME;
-- EMP_RENAME 테이블 삭제하기

DESC EMP_RENAME;
-- EMP_RENAME테이블 구성 살펴보기 ( 삭제했으니 보기X)
    
SELECT * FROM DICT;
--SCOTT 계정에서 사용 가능한 데이터 사전 살펴보기 (DICT 사용)

SELECT * FROM DICTIONARY;
-- SCOTT 계정에서 사용 가능한 데이터 사전 살펴보기 (DICTIONARY사용)SELECT TABLE_NAME FROM USER_TABLES;
-- SCOTT 계정이 가지고 있는 객체 정보 살펴보기(USER_접두어 사용)

SELECT OWNER, TABLE_NAME FROM ALL_TABLES;
-- SCOTT 계정이 가지고 있는 객체 정보 살펴보기(ALL_접두어 사용)

SELECT * FROM DBA_TABLES;
-- - SCOTT 계정DMFH DBA_ 접두어 사용하기 (SCOTT 계정은 사용권한이 없기때문에 출력X)

SELECT * FROM USER_INDEXES;
-- SCOTT 계정이 소유한 인덱스 정보 알아보기(SCOTT 계정일 때)

SELECT * FROM USER_IND_COLUMNS;
-- SCOTT 계정이 소유한 인덱스 컬럼 정보 알아보기(SCOTT계정)

CREATE INDEX IDX_EMP_SAL ON EMP(SAL);
-- EMP 테이블의 SAL 열에 인덱스를 생성하기

SELECT * FROM USER_IND_COLUMNS;
-- 생성된 인덱스 살펴보기(USER_IND_COLUMNS) 사용

DROP INDEX IDX_EMP_SAL;
-- 인덱스 삭제하기

SELECT * FROM USER_IND_COLUMNS;
-- 생성된 인덱스 살펴보기(USER_IND_COLUMNS)사용

SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP WHERE DEPTNO = 20;

--SELECT * FROM VM_EMP20; ( 뷰)

SELECT * FROM (SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP WHERE DEPTNO = 20);
-- 서브쿼리

CREATE VIEW VM_EMP20 AS (SELECT EMPNO,ENAME,JOB,DEPTNO FROM EMP WHERE DEPTNO = 20);
-- 뷰 생성하기 (토드)

SELECT * FROM USER_VIEWS;
-- 생성한 뷰 확인하기(토드)

SELECT VIEW_NAME, TEXT_LENGTH,TEXT FROM USER_VIEWS;
-- 생성한 뷰 내용 확인하기(SCOTT 계정접속했을때)

SELECT * FROM VM_EMP20;
-- 뷰 조회하기

DROP VIEW VM_EMP20;
-- 뷰 삭제하기

SELECT ROWNUM, E.* FROM EMP E;
-- ROWNUM 을 추가로 조회하기

SELECT ROWNUM , E.* FROM EMP E ORDER BY SAL DESC;
-- EMP 테이블을 SAL 열 기준으로 정렬하기

SELECT ROWNUM, E.* FROM (SELECT * FROM EMP E ORDER BY SAL DESC) E;
-- 인라인 뷰 (서브쿼리 사용)

WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC) SELECT ROWNUM, E.* FROM E;
-- 인라인 뷰 (WITH 절 사용)

SELECT ROWNUM, E.* FROM (SELECT * FROM EMP E ORDER BY SAL DESC) E WHERE ROWNUM <= 3;
-- 인라인 뷰로 TOP-N 추출하기 (서브쿼리 사용)

WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC) SELECT ROWNUM, E.* FROM E WHERE ROWNUM <= 3;
-- 인라인 뷰로 TOP-N 추출하기 (WITH사용)

CREATE TABLE DEPT_SEQUENCE AS SELECT * FROM DEPT WHERE 1<> 1;

SELECT * FROM DEPT_SEQUENCE;
-- DEPT 테이블을 사용하여 DEPT_SEQUENCE테이블 생성하기

CREATE SEQUENCE SEQ_DEPT_SEQUENCE
INCREMENT BY 10
START WITH 10
MAXVALUE 90
MINVALUE 0
NOCYCLE
CACHE 2;
-- 시퀀스 생성하기

SELECT * FROM USER_SEQUENCES;
-- 생성한 시퀀스 확인하기

INSERT INTO DEPT_SEQUENCE (DEPTNO, DNAME, LOC) VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL,'DATABASE','SEOUL');

SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;
-- 시퀀스에서 생성한 순번을 사용한 INSERT문 실행하기

SELECT SEQ_DEPT_SEQUENCE.CURRVAL FROM DUAL;
-- 가장 마지막으로 생성된 시퀀스 확인하기

INSERT INTO DEPT_SEQUENCE (DRPTNO,DNAME,LOC) VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL,'DATEBASE','SEOUL');

SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;
-- 시퀀스 에서 생성한 순번을 반복 사용하여 INSERT 문 실행하기

ALTER SEQUENCE SEQ_DEPT_SEQUENCE INCREMENT BY 3 MAXVALUE 99 CYCLE; 
--352P 하는중
--360P 시작
CREATE TABLE TABLE_NOTNULL(LOGIN_ID VARCHAR2(20) NOT NULL,LOGIN_PWD VARCHAR2(20) NOT NULL,TEL   VARCHAR2(20));

DESC TABLE_NOTNULL;
-- 테이블을 생성할 때 NOT NULL 설정하기

INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD, TEL) VALUES ('TEST_ID_01',NULL,'010-1234-5678');
-- 오류뜸 (LOGIN 에는 NOT NULL을 선언하였지만 TEL 은 별다른 선언이 없었기 때문에 오류뜸)

INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD) VALUES ('TEST_ID_01','1234');

SELECT*FROM TABLE_NOTNULL;
-- 제약 조건이 없는 TEL 열에 NULL 값 입력하기

UPDATE TABLE_NOTNULL SET LOGIN_PWD = NULL WHERE LOGIN_ID = 'TEST_ID_01';
-- NOT NULL 제약 조건이 지정된 열 데이터를 NULL 값으로 업데이트 하기

SELECT OWNER, CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME FROM USER_CONSTRAINTS;
-- 제약 조건 살펴보기 (SCOTT 계정)

CREATE TABLE TABLE_NOTNULL2(
LOGIN_ID VARCHAR2(20) CONSTRAINT TBLNN2_LGNID_NN NOT NULL,
LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLNN2_LGNPW_NN NOT NULL,
TEL     VARCHAR2(20)
);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS;
-- 테이블을 생성할 때 제약 조건에 이름 지정하기

ALTER TABLE TABLE_NOTNULL
MODIFY(TEL NOT NULL);
-- TEL 열에 NOT NULL 제약 조건 추가하기 
UPDATE TABLE_NOTNULL
SET TEL = '010-1234-5678'
WHERE LOGIN_ID = 'TEST_ID_01';

SELECT * FROM TABLE_NOTNULL;
-- TEL 열 데이터 수정하기

ALTER TABLE TABLE_NOTNULL
MODIFY(TEL NOT NULL);

SELECT OWNER, CONSTRAINT_NAME,CONSTRAINT_TYPE, TABLE_NAME 
FROM USER_CONSTRAINTS;
-- NOT NULL 제약 조건 추가하기

ALTER TABLE TABLE_NOTNULL2
MODIFY(TEL CONSTRAINT TBLNN_TEL_NN NOT NULL);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE,TABLE_NAME
FROM USER_CONSTRAINTS;
--제약조건에 이름 지정해서 추가하기

DESC TABLE_NOTNULL2;
-- TABLE_NOTBULL2 테이블 열 구조 확인하기

ALTER TABLE TABLE_NOTNULL2
RENAME CONSTRAINT TBLNN_TEL_NN TO TBLNN2_TEL_NN;

SELECT OWNER,CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS;
--이미 생성된 제약 조건 이름 변경하기

ALTER TABLE TABLE_NOTNULL2
DROP CONSTRAINT TBLNN2_TEL_NN;

DESC TABLE_NOTNULL2;
-- 제약 조건 삭제하기

CREATE TABLE TABLE_UNIQUE(
LOGIN_ID VARCHAR2(20) UNIQUE,
LOGIN_PWD VARCHAR2(20) NOT NULL,
TEL     VARCHAR2(20)
);
DESC TABLE_UNIQUE;
--제약 조건 지정하기(테이블을 생성할 때)

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME 
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TABLE_UNIQUE';
-- USER_CONSTRAINTS 데이터 사전 뷰로 제약 조건 확인하기

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD,TEL)
VALUES('TEST_ID_01','PWD01','010-1234-5678');

SELECT * FROM TABLE_UNIQUE
-- TABLE_USIQUE 테이블에 데이터 입력하기

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01','PWD01','010-1234-5678');
-- LOGIN_ID 열에 중복되는 데이터 넣기 (오류 뜸)

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD,TEL)
VALUES('TEST_ID_02','PWD01','010-1234-5678');

SELECT * FROM TABLE_UNIQUE;
-- TABLE_USIQUE 테이블에 데이터 입력하기

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD,TEL)
VALUES(NULL,'PWD01','010-2345-6789');

SELECT * FROM TABLE_UNIQUE;
-- UNIQUE 제약 조건이 지정된 열에 NULL 값 입력하기

UPDATE TABLE_UNIQUE 
SET LOGIN_ID='TEST_ID_01'
WHERE LOGIN_ID IS NULL;
-- TABLE_UNIQUE 테이블 데이터 수정하기 (오류 뜸)

CREATE TABLE TABLE_UNIQUE2(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNID_UNQ UNIQUE,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNPW_NN NOT NULL,
    TEL     VARCHAR2(20)
    );
-- 테이블을 생성할때 유니크 제약 조건 설정하기

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
-- 생성한 UNIQUE 제약 조건 확인하기 (USER_CONSTRAINTS 사용)

ALTER TABLE TABLE_UNIQUE
MODIFY(TEL UNIQUE);
-- 이미 생성한 테이블 열에 UNIQUE 제약 조건 추가하기 (오류)

UPDATE TABLE_UNIQUE
    SET TEL = NULL;
    
SELECT * FROM TABLE_UNIQUE;
-- TEL 열 값을 모두 NULL 값으로 변경하기

ALTER TABLE TABLE_UNIQUE
MODIFY(TEL UNIQUE);
-- TEL 값에 UNIQUE 제약 조건 설정하기

ALTER TABLE TABLE_UNIQUE2
MODIFY(TEL CONSTRAINT TBLUNQ_TEL_UNQ UNIQUE);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
    FROM USER_CONSTRAINTS  
   WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
-- UNIQUE 제약 조건 이름 직접 지정하기 

ALTER TABLE TABLE_UNIQUE2
RENAME CONSTRAINT TBLUNQ_TEL_UNQ TO TBLUNQ2_TEL_UNQ;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
-- 이미 만들어져 있는 UNIQUE 제약 조건 이름 수정하기

ALTER TABLE TABLE_UNIQUE2
DROP CONSTRAINT TBLUNQ2_TEL_UNQ;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
-- 제약 조건 삭제하기

CREATE TABLE TABLE_PK(LOGIN_ID VARCHAR2(20) PRIMARY KEY, LOGIN_PWD VARCHAR2(20) NOT NULL, TEL     VARCHAR2(20) );

DESC TABLE_PK;
-- 테이블을 생성할 때 특정 열에 PRIMARY KEY 설정하기

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME LIKE 'TABLE_PK%';
-- 생성한 PRIMARY KEY 확인하기

SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME FROM USER_INDEXES WHERE TABLE_NAME LIKE 'TABLE_PK%';    
-- 생성한 PRIMARY KEY 를 통해 자동 생성된 INDEX 확인하기

CREATE TABLE TABLE_PK2(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLPK2_LGNID_PK PRIMARY KEY,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLPK2_LGNPW_NN NOT NULL,
    TEL     VARCHAR2(20) 
    );
    
DESC TABLE_PK2;
-- 제약 조건의 이름을 직접 지정하여 테이블 생성하기

INSERT INTO TABLE_PK(LOGIN_ID,LOGIN_PWD,TEL) 
VALUES('TEST_ID_01','PWD01','010-1234-5678');

SELECT * FROM TABLE_PK;
--TABLE_PK 테이블에 데이터 입력하기

INSERT INTO TABLE_PK(LOGIN_ID,LOGIN_PWD,TEL)
VALUES('TEST_ID_01','PWD02','010-2345-6789');
-- TABLE_PK 테이블에 중복되는 데이터 입력하기

INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD,TEL)
VALUES(NULL,'PWD02','010-2345-6789');
-- NULL값을 명시적으로 입력하기

INSERT INTO TABLE_PK(LOGIN_PWD,TEL)
VALUES('PWD02','010-2345-6789');
-- NULL 값을 암시적으로 입력하기 
-- 둘다 오류 뜸. 

CREATE TABLE TABLE_NAME(
COL1 VARCHAR2(20) CONSTRAINT CONSTRAINT_NAME PRIMARY KEY,
COL2 VARCHAR2(20) NOT NULL,
COL3 VARCHAR2(20)
);

CREATE TABLE TABLE_NAME(
COL1 VARCHAR2(20),
COL2 VARCHAR2(20),
COL3 VARCHAR(20),
PRIMARY KEY (COL1),
CONSTRAINT CONSTRAINT_NAME UNIQUE (COL2)
);
-- CREATE 문에서 제약 조건을 지정하는 다른 방식

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_OWNER, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('EMP','DEPT');
-- EMP 테이블과 DEPT 테이블의 제약 조건 살펴보기

INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES(9999,'홍길동','CLERK','7789',TO_DATE('2017/04/30','YYYY/MM/DD'),1200,NULL,50);
-- FOREIGN KEY가 참고하는 열에 존재하지 않는 데이터 입력하기
-- 언급한 부모 키가 없습니다 라는 오류는 DEPT 테이블의 DEPTNO열에 50이 존재하지않는다는 뜻.

CREATE TABLE DEPT_FK(
DEPTNO NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY,
DNAME VARCHAR2(14),
LOC  VARCHAR2(13)
);

DESC DEPT_FK;
--DEPT_FK 테이블 생성하기

CREATE TABLE EMP_FK(
EMPNO   NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
ENAME   VARCHAR2(10),
JOB     VARCHAR2(9),
MGR     NUMBER(4),
HIREDATE DATE,
SAL     NUMBER(7,2),
COMM    NUMBER(7,2),
DEPTNO  NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK (DEPTNO)
);

DESC EMP_FK;
-- EMP_FK 테이블 생성하기

INSERT INTO EMP_FK
VALUES(9999,'TEST_NMAME','TEST_JOB',NULL,TO_DATE('2001/01/01','YYYY/MM/DD'),
3000,NULL,10);
-- EMP_FK 테이블에 데이터 삽입하기(DEPTNO 데이터가 아직 DEPT_FK테이블에 없을때)

INSERT INTO DEPT_FK
VALUES(10, 'TEST_DNAME','TEST_LOC');

SELECT*FROM DEPT_FK;
--DEPT_FK 에 데이터 삽입히가

INSERT INTO EMP_FK
VALUES(9999,'TEST_NMAME','TEST_JOB',NULL,TO_DATE('2001/01/01','YYYY/MM/DD'),
3000,NULL,10);
SELECT * FROM EMP_FK;
-- EMP_FK 테이블에 데이터 삽입하기

DELETE FROM DEPT_FK
WHERE DEPTNO = 10;
-- DEPT_FK 테이블의 10번 부서 데이터 삭제하기 (오류)

CREATE TABLE TABLE_CHECK(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLCK_LOGINID_PK PRIMARY KEY,
    LOGIN_PWD VARCHAR(20) CONSTRAINT TBLCK_LOGINPW_CK CHECK (LENGTH(LOGIN_PWD)>3),
    TEL     VARCHAR(20)
);
    
DESC TABLE_CHECK;
-- 테이블을 생성할떄 CHECK 제약 조건 설정하기

INSERT INTO TABLE_CHECK
VALUES ('TEST_ID','123','010-1234-5678');
-- CHECK 제약조건에 맞지 않는 예 (오류)

INSERT INTO TABLE_CHECK
VALUES ('TEST_ID','1234','010-1234-5678');

SELECT * FROM TABLE_CHECK;
-- CHECK 제약 조건에 맞는 예

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE,TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_CHECK';
-- SELECT 제약 조건 확인하기

CREATE TABLE TABLE_DEFAULT(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLCK2_LOGINID_PK PRIMARY KEY,
    LOGIN_PWD VARCHAR2(20) DEFAULT'1234',
    TEL     VARCHAR2(20)
    );

DESC TABLE_DEFAULT;
-- 테이블을 생성할 때 DEFAULT 제약 조건 설정하기

INSERT INTO TABLE_DEFAULT VALUES ('TEST_ID',NULL,'010-1234-5678');

INSERT INTO TABLE_DEFAULT (LOGIN_ID, TEL) VALUES ('TEST_ID2','010-1234-5678');

SELECT * FROM TABLE_DEFAULT;
-- DEFAULT로 지정한 기본값이 입력되는 INSERT문 확인하기

REVOKE SELECT, INSERT ON TEMP FROM ORCLSTUDY;

GRANT SELECT ON EMP TO PREV_HW;

REVOKE SELECT ON EMP FROM PREV_HW;

REVOKE SELECT ON DEPT FROM PREV_HW;

REVOKE SELECT ON SALGRADE FROM PREV_HW;


